;;; 游戏循环
;;; 由于需要调用 类型的值,所以这部分直接写成库文件的一部分  -- 230117
;;; 见 chez-sdl sdl-extend.sls
(define (游戏循环 game-obj core-foo)
  ;; 为了避免出现1的那个版本,每套局部都要对各个事件对应的hash-table进行赋值的情况;
  ;; 同时为了避免closure中每增添一个事件就要修改源代码的情况
  ;; 意识到了事件和状态的本质都是谓词之后,通过给事件循环的构造器返回一个传入函数,将传入的函数应用到事件类型上得到了现在的2.0  -- 2023年2月15日21:03:31
  ;; 因为图形拖动遇到了问题,意识到了原作者的一堆事件谓词之后,不需要自己手工访问 SDL_Event,有了现在的3.0--- 2023年2月16日20:11:20
  ;; 由于昨天的进步,不需要放进库文件了... -- 2023年2月17日17:25:40
  ;; 固定更新时间步长,动态渲染?游戏设计模式一书提到的方式  2024年7月28日16:09:10
  ;; 飞机大战里面是循环套了循环了.....
  ;; (let ((上一时间戳 (sdl-get-ticks))
  ;; 	(时间间隔 0)
  ;; 	(累积时间间隔 0)))
  (let loop ((随便什么 1))
    ;; (set! 时间间隔 (- 时间戳 上一时间戳))
    ;; (set! 上一时间戳 时间戳)
    ;; (set! 累积时间间隔 (+ 累积时间间隔 时间间隔))		;会在game-eval中减去每帧时长然后赋值给自己...
    (sdl-poll-event)
    (if (sdl-event-quit?)
	(begin
	  (printf "游戏循环结束!~n")
	  ((get-quit-foo game-obj)))
	(begin
	  ;; (game-read )
	  (core-foo 'msg)
	  ;; (game-print )
	  (loop 1)
	  ))
    )
  )

(define (游戏循环-thread game-obj core-foo)
  ;; 为了避免出现1的那个版本,每套局部都要对各个事件对应的hash-table进行赋值的情况;
  ;; 同时为了避免closure中每增添一个事件就要修改源代码的情况
  ;; 意识到了事件和状态的本质都是谓词之后,通过给事件循环的构造器返回一个传入函数,将传入的函数应用到事件类型上得到了现在的2.0  -- 2023年2月15日21:03:31
  ;; 因为图形拖动遇到了问题,意识到了原作者的一堆事件谓词之后,不需要自己手工访问 SDL_Event,有了现在的3.0--- 2023年2月16日20:11:20
  ;; 由于昨天的进步,不需要放进库文件了... -- 2023年2月17日17:25:40
  ;; 固定更新时间步长,动态渲染?游戏设计模式一书提到的方式  2024年7月28日16:09:10
  ;; (let ((上一时间戳 (sdl-get-ticks))
  ;; 	(时间间隔 0)
  ;; 	(累积时间间隔 0)))
  (fork-thread (lambda ()
		 (let loop ((随便什么 1))
		   ;; (set! 时间间隔 (- 时间戳 上一时间戳))
		   ;; (set! 上一时间戳 时间戳)
		   ;; (set! 累积时间间隔 (+ 累积时间间隔 时间间隔))		;会在game-eval中减去每帧时长然后赋值给自己...
		   (sdl-poll-event)
		   (if (sdl-event-quit?)
		       (begin
			 (printf "游戏循环结束!~n")
			 ((get-quit-foo game-obj)))
		       (begin
			 ;; (game-read )
			 (core-foo 'msg)
			 ;; (game-print )
			 (loop 1)
			 ))
		   )))
    )


(define (游戏循环 game-obj 更新foo . 渲染等需要插值预测的foo)
  ;; 为了避免出现1的那个版本,每套局部都要对各个事件对应的hash-table进行赋值的情况;
  ;; 同时为了避免closure中每增添一个事件就要修改源代码的情况
  ;; 意识到了事件和状态的本质都是谓词之后,通过给事件循环的构造器返回一个传入函数,将传入的函数应用到事件类型上得到了现在的2.0  -- 2023年2月15日21:03:31
  ;; 因为图形拖动遇到了问题,意识到了原作者的一堆事件谓词之后,不需要自己手工访问 SDL_Event,有了现在的3.0--- 2023年2月16日20:11:20
  ;; 由于昨天的进步,不需要放进库文件了... -- 2023年2月17日17:25:40
  ;; 固定更新时间步长,动态渲染?游戏设计模式一书提到的方式  2024年7月28日16:09:10
  ;; 飞机大战里面是循环套了循环了.....
  ;; (let ((上一时间戳 (sdl-get-ticks))
  ;; 	(时间间隔 0)
  ;; 	(累积时间间隔 0)))

  (let ((更新最大追逐次数 10)
	(脉冲间隔 0)			;应该只在游戏循环中使用
	(累积时间间隔 0)
	)
    (let loop ((随便什么 1))
      ;; (set! 时间间隔 (- 时间戳 上一时间戳))
      ;; (set! 上一时间戳 时间戳)
      ;; (set! 累积时间间隔 (+ 累积时间间隔 时间间隔))		;会在game-eval中减去每帧时长然后赋值给自己...
      (sdl-poll-event)
      (if (sdl-event-quit?)		;或者专门做个退出状态
	  (begin
	    (printf "游戏循环结束!~n")
	    ((get-quit-foo game-obj)))
	  (begin
	    (set! 脉冲间隔 (获取时间戳 (计时器0))) ;大的离谱..... 2024年7月29日01:18:26
	    ;; (set! 时间间隔 (获取时间戳 计时器0))
	    (启动 (计时器0)) 	;重置计时器,下次获取时间坐标时就是时间间隔
	    (set! 累积时间间隔 (+ 脉冲间隔 累积时间间隔))
	    (let loop ((lag 累积时间间隔)
		       (次数 0))
	      (cond ((< 次数 更新最大追逐次数)
		     (if (>= lag 时间间隔)
			 (begin
			   ;; (测试输出 (list '当前累积时间 (floor lag)))
			   (call/cc
			    (lambda (k)
			      (更新foo k)))		;切换状态时候直接(k (新状态更新 k)),如果续延用起来有问题,可以let一个foo的绑定,切换用赋值实现
			   ;; (obj更新 游戏状态 '() '() 谓词-act并联映射 游戏状态谓词-actls)
			   (loop (- lag 时间间隔)
				 (+ 次数 1)))
			 (begin
			   (set! 累积时间间隔 lag)
			   (uprocapply 渲染等需要插值预测的foo (/ lag 时间间隔)) ;可能需要插值预测
			   )
			 ))
		    (else
		     (uprocapply 渲染等需要插值预测的foo 1) ;尝试到了最大次数,依然追不上实际时间
		     )))
	    
	    (loop 1)
	    ))
      ))
  )


(define (uprocapply thunkls x)
  (cond ((null? thunkls) '())
	(else
	 ((car thunkls) x)
	 (uprocapply (cdr thunkls) x)
	 )))
