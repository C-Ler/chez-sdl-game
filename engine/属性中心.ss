;;;
;;;

;;; 属性统一用数组的hash-table
;; 生命值
;; 对象1 100
;; 对象2 100

;; 二维坐标
;; 对象1 vec 100 100
;; 对象2 vec 100 100

;;; 建立对象ID同对象其它值的关联
;; id-name
;; 对象1 车
;; 对象2 船


;;; 数据驱动,告别gameobject(主要提供一个唯一ID,便于组件之间互相影响)的纯组件模式
;;; 以属性为中心,连续的存储,数组的结构,但是难以将某一对象整个拉取,初始值倒也好设置,直接全都填充
;;; 


;;; 根据ID 属性 索引 获取值 (三维空间的点)
;;; 如果属性-索引也用vec存储,效率岂不是更进一步,如果属性-值没法用vec,岂不是退化到其他情况
(define (get ID 属性 store)
  ;; 因为并不是所有对象都有同样的属性,所以各个属性的长度并不一致
  ;; 因为以上,所以直接用ID作为索引且不判断ID是否关联某个属性,可能取出其它ID的属性
  ;; 因为以上,所以需要一个将ID同所含的属性关联起来的结构:ID-属性映射ht
  (let ((属性ls (get-属性ls ID ID-属性映射ht))
	(索引 (get-索引 属性 属性ls)))
    ;; 属性ls应该也是二维键值表,因为属性也是个绑定,属性-索引的绑定
    (when 索引
      ;; store 应该是一个类似属性-vec的结构,所以有了属性-vecht
      ;; 接着按照索引获取属性的值,接下来的问题是:如果同一个属性可能有不同结构的值?
      (vector-ref (hashtable-ref store 属性 #()) 索引)
      )
    )
  )

(define ID-属性映射ht (make-eq-hash-table)) ;ID保存一堆属性的列表 k:ID,v:(属性1 属性2 ...)

(define 属性-vecht (make-eq-hash-table))

(define (get-属性ls ID)
  (hashtable-ref ID-属性映射ht ID '()))

|# 创建新的对象可能遇到的问题:
1. 没有已知的属性--新增属性
2.拥有已知的属性
 但是放不下了,所以要扩展空间
 能放下,所以怎样知道放在哪里
3.创建拥有同样属性的对象的过程
4.批量创建对象的情况.
5.对象的某一属性值存在共享的情况:比如某一纹理
#|

(define (新建对象 ID . kvpair)
  ;; 所以ID应该怎样构造?
  ;; 默认的属性值
  ;; 给对象增加属性的可行性,必要性
  
  
  
  )

|#
不同的分组方式
查询附近需要碰撞检测的对象
查询
#|

|#
切换状态但是只保留部分对象如何处理?
选项1.销毁不用部分
选项2.整个重置
#|

(define 某个具体属性的ht (make-eq-hash-table))

(define 我方飞机 (get-obj 0 world))

|#
脚本化的情况
灵活扩展的能力
#|



;;; 最后还是要make,get,set

;;; 这样感觉可以直接用一套脚本,包进一个大的闭包,留下get和set之类的接口....
;;; 其实和解释器一样,环境,存储,控制流

